"""Video generator node - generates video segments using Replicate Veo."""

import tempfile
from pathlib import Path

from moviepy import VideoFileClip
from PIL import Image as PILImage

from ..exceptions import ModerationError
from ..services.gemini_planner import generate_cta_last_frame
from ..services.replicate_client import create_and_download_video
from ..state import SegmentVideo, VideoGeneratorState
from ..utils.logging import log, log_separator


def extract_last_frame_from_bytes(video_bytes: bytes) -> bytes:
    """Extract the last frame from video bytes.

    Args:
        video_bytes: Video file contents as bytes

    Returns:
        PNG image bytes of the last frame
    """
    log("Extracting last frame from video bytes...")

    with tempfile.NamedTemporaryFile(suffix=".mp4", delete=False) as tmp_file:
        tmp_file.write(video_bytes)
        tmp_path = Path(tmp_file.name)

    try:
        with VideoFileClip(str(tmp_path)) as clip:
            # Get the last frame (at duration - small epsilon to avoid edge issues)
            last_time = max(0, clip.duration - 0.01)
            frame = clip.get_frame(last_time)

            # Convert numpy array to PIL Image and save to bytes
            pil_image = PILImage.fromarray(frame)

            with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as img_tmp:
                pil_image.save(img_tmp.name)
                image_bytes = Path(img_tmp.name).read_bytes()
                Path(img_tmp.name).unlink()

            log(f"Last frame extracted: {len(image_bytes)} bytes")

        return image_bytes
    finally:
        # Clean up temp video file
        tmp_path.unlink(missing_ok=True)


def generate_video_segment(state: VideoGeneratorState) -> dict:
    """Generate a single video segment using Replicate Veo.

    New workflow:
    - Scene 1 (HOOK): image=first_frame (Nano Banana generated)
      → Video starts from the pre-generated first frame
      → Extract last frame after generation
    - Scene 2 (CTA): image=scene1_last_frame, last_frame=cta_last_frame
      → Interpolation mode: creates transition from scene1 end to product reveal
      → CTA last frame generated by Nano Banana with product image
    """
    segments = state["segments"]
    current_idx = state["current_segment_index"]

    # Frame images from state
    first_frame_image = state.get("first_frame_image")
    scene1_last_frame_image = state.get("scene1_last_frame_image")
    cta_last_frame_image = state.get("cta_last_frame_image")

    # For CTA last frame generation
    product_image_url = state.get("product_image_url")
    product_detail = state.get("product_detail", {})
    script_json = state.get("script_json", {})
    characters = script_json.get("characters", {})

    if current_idx >= len(segments):
        return {"status": "generation_complete"}

    seg = segments[current_idx]
    scene_num = current_idx + 1
    total_scenes = len(segments)

    log_separator(f"Scene {scene_num}/{total_scenes} Generation")

    prompt = seg["prompt"]
    is_first_scene = current_idx == 0
    is_second_scene = current_idx == 1

    # Determine generation strategy
    if is_first_scene:
        # Scene 1: image-to-video from first frame
        first_frame = first_frame_image
        last_frame = None
        strategy = "Scene 1 - image-to-video (first_frame from Nano Banana)"
    elif is_second_scene:
        # Scene 2: Need to generate CTA last frame first (if not already done)
        if not cta_last_frame_image and product_image_url and scene1_last_frame_image:
            log_separator("Generating CTA Last Frame (Nano Banana)")

            # Extract Scene 2's last timeline action for the CTA frame prompt
            cta_action = None
            scenes = script_json.get("scenes", [])
            if len(scenes) >= 2:
                scene2 = scenes[1]
                timeline = scene2.get("timeline", [])
                if timeline:
                    # Get the last sequence's action
                    last_seq = timeline[-1]
                    cta_action = last_seq.get("action", "")
                    log(f"CTA action from script: {cta_action[:100]}...")

            cta_last_frame_image = generate_cta_last_frame(
                scene1_last_frame=scene1_last_frame_image,
                product_image_url=product_image_url,
                product_detail=product_detail,
                characters=characters,
                cta_action=cta_action,
            )

        # Scene 2: interpolation mode (image → last_frame)
        first_frame = scene1_last_frame_image
        last_frame = cta_last_frame_image
        strategy = "Scene 2 - interpolation (scene1_last → cta_last with product)"
    else:
        # Scene 3+: continue from previous last frame (if any)
        first_frame = scene1_last_frame_image
        last_frame = None
        strategy = f"Scene {scene_num} - image-to-video continuation"

    log(f"Title: {seg.get('title', '(no title)')}")
    log(f"Duration: {seg['seconds']}s")
    log(f"Strategy: {strategy}")
    log(f"First frame (image): {'yes' if first_frame else 'no'}")
    log(f"Last frame (interpolation): {'yes' if last_frame else 'no'}")

    log("Scene prompt (full):")
    print("-" * 40)
    print(prompt)
    print("-" * 40)

    try:
        # Generate video and get bytes directly
        video_bytes = create_and_download_video(
            prompt=prompt,
            first_frame=first_frame,
            last_frame=last_frame,
            duration=seg["seconds"],
        )

        log(f"Scene {scene_num} generated: {len(video_bytes)} bytes")

        # Extract last frame for next scene's continuity
        new_last_frame = extract_last_frame_from_bytes(video_bytes)

        log(f"Scene {scene_num} processing complete!")

        # Build return state with segment video data
        segment_video: SegmentVideo = {
            "video_bytes": video_bytes,
            "index": current_idx,
            "title": seg.get("title", f"Segment {scene_num}"),
        }

        result = {
            "segment_videos": [segment_video],
            "current_segment_index": current_idx + 1,
            "status": "segment_generated",
        }

        # Store scene1 last frame for scene2
        if is_first_scene:
            result["scene1_last_frame_image"] = new_last_frame

        # Store CTA last frame if generated
        if is_second_scene and cta_last_frame_image:
            result["cta_last_frame_image"] = cta_last_frame_image

        return result

    except ModerationError as e:
        log(f"Scene {scene_num} MODERATION error, skipped: {e}", "WARNING")
        return {
            "skipped_segments": [scene_num],
            "current_segment_index": current_idx + 1,
            "status": "segment_skipped",
        }

    except Exception as e:
        log(f"Scene {scene_num} generation failed: {e}", "ERROR")
        return {
            "skipped_segments": [scene_num],
            "current_segment_index": current_idx + 1,
            "status": "segment_failed",
        }
